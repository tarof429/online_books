= Kubernetes with ArchLinux

== Part 1

=== Introduction

ArchLinx is my favorite Linux distribution, and in this tutorial I am going to explain how to develop, deploy and manage a Kubernetes application on ArchLinux. We will first setup our development environment to the point where we can deploy pods to Minikube, a single node Kubernetes cluster. Next, we will take an exisiting Go application, turn it into a microservice, and deploy it to Minikube. Then to make our deployment more realistic, we will deploy some services and start to explore some tools to get insights into our cluster. In the next step, will will create a CI/CD pipeline and deploy our application to the cloud. We round out our tutorial with an exploration into additional tools used to deploy Kubernetes clusters. Finally, we will attempt to come up with a concise list of tools that you need to successfully use Kubernetes with ArchLinux, and delve into discussions into 


The technology stack tht we'll look into is as follows:

- ArchLinux
- Docker
- Minikube
- Kubernetes
- Go
- Python
- Jenkins
- Spinaker
- GKE
- AWS

== Setting up your development environment

=== Configuring Docker
If you've been using Docker on your machine for any amount of time, chances are you have lots of containers and images that are eating valuable disk space. If possible, take this opportunity to clean up your system! You can use `docker system prune` to remove all stopped containers, dangling images, and unused networks. You can also use `docker image prune -a` to remove all unused images, not just dangling ones. Also make sure you run `docker volume prune` to remove all your volumes. Why go through this step? Ever since I started to use docker and minikube on my system, I've noticed that the free disk space on my `/` partition has been steadily decreasing. That's because all docker images, containers, volumes and layers are stored under /var/lib/docker/ In my case, /var is part of my `/` partition which is actually on a small NVMe drive. Due to the design of my motherboard, my NVMe slot is on the underside of my motherboard making maintenance and upgrading a hassle. 

In any case, the location of docker images and volumes is configurable, and so for our development environment, lets change it. What we want to do is configure the Docker system daemon. Here we have some choices. We can either edit the service file at /lib/systemd/system/docker.service or edit the docker daemon configuration file at /etc/docker/daemon.json. A third option which could work for us is to use soft links. 

The official docker daemon configuration page at https://docs.docker.com/config/daemon will tell you about the first two methods, while the third option is something that you'll find if you do a Google search with the phrase "how to change the default location for docker create volume". On ArchLinux, systemd is the most popular init system used; however, it is by no means the only one. So let's avoid changing a service file and instead look into editing `daemon.json`. As the file extension suggests, this is a JSON file. Mine looks like this:

[source,json]
----
{
	"dns": ["192.168.10.1", "8.8.8.8"]
}
----

What we can do is change this file so that data asssociated with docker is on the /home partition, which has a lot more free disk space.

[source,json]
----
{
	"dns": ["192.168.10.1", "8.8.8.8"],
    "data-root": "/home/docker"
}
----

What we are going to do is the following in terminal A:

[source,sh]
----
$ su root
# journalctl -f -u docker
----

In terminal B, we'll make the change:

[source,sh]
----
$ su root
# mv /var/lib/docker to /home/docker
# systemctl restart dockerd
----

If you're unsure of the syntax of this file, I suggest that you look at the CommonConfig struct for docker at https://raw.githubusercontent.com/docker/engine/master/daemon/config/config.go. You should see that the Root field is a string and is mapped to data-root.

Once done, try pulling and running hello-world to verify that docker is working.

